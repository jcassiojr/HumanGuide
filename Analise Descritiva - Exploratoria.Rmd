---
title: "Análise Descritiva - Exploratória - DRAFT"
author: "José Cassio"
date: "December 18, 2015"
output:
  html_document
---

![agileBIGDATA](./aBIG5.png)

Este documento descreve a análise descritiva realizada com o objetivo de definir a influência dos componentes obtidos do teste **Human Guide** por meio da técnica de análise de componentes principais.

### Preparação dos dados ###
Foram obtidos os dados brutos da seguinte fonte:

* Classificacao das carreiras-V2.xlsx

Abaixo segue um exemplo com a parte inicial do arquivo:

```{r,echo=FALSE}
require("doMC", quietly = TRUE, warn.conflicts = FALSE)
require("xlsx", quietly = TRUE, warn.conflicts = FALSE)
require("dplyr", quietly = TRUE, warn.conflicts = FALSE)
registerDoMC(5) # parallel processing
df_class.carr <- read.xlsx2("./data/Classificacao das carreiras-V2.xlsx", sheetIndex = 1, header = TRUE)
# preparando os dados para as pesquisas a frente
df_class.carr <- mutate_each(df_class.carr, funs(tolower)) # forçando minúsculas
# tirando acentuação e espaço em branco em excesso
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("á", "a", x))))
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("é", "e", x))))
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("í", "i", x))))
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("ó", "o", x))))
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("ú", "u", x))))
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("ã", "a", x))))
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("õ", "o", x))))
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("ç", "c", x))))
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("â", "a", x))))
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("ê", "e", x))))
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("ô", "o", x))))
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("  ", " ", x))))

knitr::kable(head(df_class.carr))
```


----

### Arquivo Processado ###

A partir do arquivo acima, foram classificadas as profissões informadas pelos respondentes no arquivo previamente obtido com as médias de scores por componentes para cada profissão, conforme exemplo abaixo:

*IMPORTANTE:* Critério para considerar a classe INDEFINIDA: profissões que não aparecem na tabela de Classes de Profissões : as profissões abaixo não aparecerem na tabela de Rosane Schotgues Levenfus, usada como base para a classificação apresentada aqui.


```{r,echo=FALSE}
require("stringr", quietly = TRUE, warn.conflicts = FALSE)
require("reshape2", quietly = TRUE, warn.conflicts = FALSE)

source("./R/f_le_raw_HG.R") # usar esta função para ler os dados novos. 
source("./R/f_tidy_scores_HG.R") # alterada em 07/12/2015 para trazer nome do respondente tb
df_raw_hg <- f_le_raw_HG() # retorna colunas: todas
df_tidy_hg <- f_tidy_scores_HG(df_raw_hg)
# tirar formacoes: ensino medio, ensino tecnico, ensino fundamental, INDEFINIDO, ensino tecnologico
# tirar ocupacoes: estagiario, estudante, dona de casa, consultoria, comercio, entre empregos, do lar, empresario,
# bancario, aposentado/a, terceiro setor, INDEFINIDO, mudar docência/magisterio para magisterio, mudar Latim para letras, 
# Obtendo os dados das respostas
#my.newdata <- df_tidy_hg
# obtendo os scores previstos
pca1 = prcomp(df_tidy_hg[,7:14], scale. = TRUE, center = TRUE)
# selecionando apenas amostra para rapidez de processamanto (posteriormente colocar em combobox)
tam.amostra = 1000
my.newdata <- 
    df_tidy_hg %>%
    sample_n(tam.amostra)
# fazendo para toda a base
#my.newdata.carr <- df_tidy_hg
#tam.amostra = dim(my.newdata)[1]

# calculando os scores
my.prev <- as.data.frame(predict(pca1, newdata=my.newdata))
# criando dataframe por carreira e profissão
my.prev <- cbind(ID = my.newdata$ID, profissao.na.area.de = my.newdata$profissao.na.area.de, 
                      formacao.em = my.newdata$formacao.em,
                      my.prev)

# tirando acentuação e espaço em branco em excesso e forçando minusculas
my.prev <- mutate_each(my.prev, funs(tolower)) # forçando minúsculas
my.prev <- as.data.frame(sapply(my.prev, FUN = function(x) as.character(gsub("á", "a", x))))
my.prev <- as.data.frame(sapply(my.prev, FUN = function(x) as.character(gsub("é", "e", x))))
my.prev <- as.data.frame(sapply(my.prev, FUN = function(x) as.character(gsub("í", "i", x))))
my.prev <- as.data.frame(sapply(my.prev, FUN = function(x) as.character(gsub("ó", "o", x))))
my.prev <- as.data.frame(sapply(my.prev, FUN = function(x) as.character(gsub("ú", "u", x))))
my.prev <- as.data.frame(sapply(my.prev, FUN = function(x) as.character(gsub("ã", "a", x))))
my.prev <- as.data.frame(sapply(my.prev, FUN = function(x) as.character(gsub("õ", "o", x))))
my.prev <- as.data.frame(sapply(my.prev, FUN = function(x) as.character(gsub("ç", "c", x))))
my.prev <- as.data.frame(sapply(my.prev, FUN = function(x) as.character(gsub("â", "a", x))))
my.prev <- as.data.frame(sapply(my.prev, FUN = function(x) as.character(gsub("ê", "e", x))))
my.prev <- as.data.frame(sapply(my.prev, FUN = function(x) as.character(gsub("ô", "o", x))))
my.prev <- as.data.frame(sapply(my.prev, FUN = function(x) as.character(gsub("  ", " ", x))))

# PROFISSAO x CLASSE
# criando novo dataframe para tratar mais de uma profissão por classe de carreira
#----------------------------------------------------------------------------------
df_carr <- data.frame()

for (j in 1:ncol(df_class.carr)) {
    # percorre todas as linhas da coluna corrente de df_class.carr
    for (i in 1:length(my.prev$profissao.na.area.de)) {
        # somente pega o string com match exato (ex. administração)
        i_aux <- sum(!is.na(str_match(df_class.carr[,j],
                                      paste0("^", as.character(my.prev$profissao.na.area.de[i]), "$"))))
        # para cada profissão encontrada em uma determinada classe, marca a posição correspondente
        # com 1, na célula do dataframe correspondente. Caso contrario, coloca NA
        if(i_aux) {
            df_carr[i,j] = i_aux
        } else {
            df_carr[i,j] = NA
        }
    }
}
# colocando os nomes das classes no dataframe gerado
names(df_carr) <- colnames(df_class.carr)

# concatenando a coluna de profissoes ao dataframe gerado
my.prev.carr <- cbind(my.prev, df_carr)

# duplicar colunas que aparecem com mais de uma classe

# transformando colunas em valores por linha, eliminando NAs, de forma a poder ter os scores de
# cada profissão duplicado para cada classe onde a profissão se encontra
# Desta forma, a análise não perde a contribuição do score de cada profissão para cada classe
carrMelt <- melt(my.prev.carr,id=c("ID","profissao.na.area.de","formacao.em",
                                   "PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8"),
                  measure.vars=colnames(df_class.carr), na.rm = TRUE)
# mudando o nome da variavel de classe
colnames(carrMelt)[12] <- "class.carr"
# eliminando coluna desnecessária
my.prev.carr <-
    carrMelt %>%
    select (-value)

knitr::kable(head(my.prev.carr))

#++++
# FORMACAO x CLASSE
# criando novo dataframe para tratar mais de uma formacao por classe de carreira
#----------------------------------------------------------------------------------
df_form <- data.frame()

for (j in 1:ncol(df_class.carr)) {
    # percorre todas as linhas da coluna corrente de df_class.carr
    for (i in 1:length(my.prev$formacao.em)) {
        # somente pega o string com match exato (ex. administração)
        i_aux <- sum(!is.na(str_match(df_class.carr[,j],
                                      paste0("^", as.character(my.prev$formacao.em[i]), "$"))))
        # para cada profissão encontrada em uma determinada classe, marca a posição correspondente
        # com 1, na célula do dataframe correspondente. Caso contrario, coloca NA
        if(i_aux) {
            df_form[i,j] = i_aux
        } else {
            df_form[i,j] = NA
        }
    }
}
# colocando os nomes das classes no dataframe gerado
names(df_form) <- colnames(df_class.carr)

# concatenando a coluna de profissoes ao dataframe gerado
my.prev.form <- cbind(my.prev, df_form)

# duplicar colunas que aparecem com mais de uma classe
# transformando colunas em valores por linha, eliminando NAs, de forma a poder ter os scores de
# cada profissão duplicado para cada classe onde a profissão se encontra
# Desta forma, a análise não perde a contribuição do score de cada profissão para cada classe
carrMelt <- melt(my.prev.form,id=c("ID","profissao.na.area.de","formacao.em",
                                   "PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8"),
                  measure.vars=colnames(df_class.carr), na.rm = TRUE)
# mudando o nome da variavel de classe
colnames(carrMelt)[12] <- "class.carr"
# eliminando coluna desnecessária
my.prev.form <-
    carrMelt %>%
    select (-value)

knitr::kable(head(my.prev.form))
#++++

# SEPARANDO SOMENTE RESPONDENTES QUE MUDARAM DE CLASSE de formação -> ocupação
# 1. fazer inner join para identificar se ao menos uma classe de carreira coinncide com uma classe de formacao
# obs: preciso do ID do respondente para a chave do inner join
df_sem.mov <- inner_join(my.prev.form[,c(1:3,12)], my.prev.carr[,c(1,12)],by=c("ID", "class.carr"))
# tirando a duplicidade dos IDs dos respondentes sem movimento
df_sem.mov <-
    df_sem.mov %>%
    distinct(ID)
# obtendo respondentes com movimento a partir dos dados originais processados
df_com.mov <-
    my.newdata %>%
    filter(!(ID %in% df_sem.mov$ID))
    
# obs: antes dessa análise, preciso excluir as seguintes carreiras:
# e as seguintes formações: Entre Empregos, INDEFINIDO




```

### BoxPlots de Scores da Classes de Profissões por Componentes ###

Abaixo seguem os boxplots da distribuição dos scores agrupados por classes de componentes para todos os dados da amostra:

```{r, echo=FALSE}
knitr::kable(tam.amostra, caption = "TAMANHO DA AMOSTRA")
```



----



```{r, echo=FALSE, warning=FALSE}
# box plot
require("plotly", quietly = TRUE, warn.conflicts = FALSE)
pc1 <- plot_ly(my.prev.carr, x = PC1, color = class.carr, type = "box")
pc1 <- layout(pc1, title = "OPENNESS/EXPLORATION x COMPLIANCE/OBSERVÂNCIA")
pc1
```


----



```{r, echo=FALSE, warning=FALSE}
# box plot
pc2 <- plot_ly(my.prev.carr, x = PC2, color = class.carr, type = "box")
pc2 <- layout(pc2, title = "AGREEABLENESS/AMABILIDADE x ANALÍTICO E INDEPENDENTE/FOCO EM RESULTADO")
pc2
```


----



```{r, echo=FALSE, warning=FALSE}
# box plot
pc3 <- plot_ly(my.prev.carr, x = PC3, color = class.carr, type = "box")
pc3 <- layout(pc3, title = "INVESTIGATIVO/RESEARCH ORIENTED x COMMITMENT/ENGAJAMENTO")
pc3
```


----



```{r, echo=FALSE, warning=FALSE}
# box plot
pc4 <- plot_ly(my.prev.carr, x = PC4, color = class.carr, type = "box")
pc4 <- layout(pc4, title = "PEOPLE DEVELOPMENT ORIENTED x TASK ORIENTED/ORIENTAÇÃO PARA A TAREFA")
pc4
```


----



```{r, echo=FALSE, warning=FALSE}
# box plot
pc5 <- plot_ly(my.prev.carr, x = PC5, color = class.carr, type = "box")
pc5 <- layout(pc5, title = "EXTROVERSÃO/AUTENTICIDADE x SOBRIEDADE/COMPOSTURA/COMEDIMENTO")
pc5
```


----



```{r, echo=FALSE, warning=FALSE}
# box plot
pc6 <- plot_ly(my.prev.carr, x = PC6, color = class.carr, type = "box")
pc6 <- layout(pc6, title = "MANAGEMENT/ASSISTÊNCIA/RECEPTIVIDADE ATIVA")
pc6
```


----



```{r, echo=FALSE, warning=FALSE}
# box plot
pc7 <- plot_ly(my.prev.carr, x = PC7, color = class.carr, type = "box")
pc7 <- layout(pc7, title = "AUSTERIDADE/PONDERAÇÃO x ADAPTABILIDADE/AJUSTAMENTO)")
pc7
```

