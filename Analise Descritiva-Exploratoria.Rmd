---
title: "Análise Descritiva - Exploratória - DRAFT"
author: "José Cassio"
date: "December 18, 2015"
output:
  html_document
---

![agileBIGDATA](./aBIG5.png)

Este documento descreve a análise descritiva realizada com o objetivo de definir a influência dos componentes obtidos do teste **Human Guide** por meio da técnica de análise de componentes principais.

### Preparação dos dados ###

Foram obtidos os dados brutos da seguinte fonte:

* Classificacao das carreiras-V2.xlsx

Abaixo segue um exemplo com a parte inicial do arquivo:

```{r,echo=FALSE}
require("doMC", quietly = TRUE, warn.conflicts = FALSE)
require("xlsx", quietly = TRUE, warn.conflicts = FALSE)
require("dplyr", quietly = TRUE, warn.conflicts = FALSE)
registerDoMC(5) # parallel processing
df_class.carr <- read.xlsx2("./data/Classificacao das carreiras-V2.xlsx", sheetIndex = 1, header = TRUE)
# preparando os dados para as pesquisas a frente
df_class.carr <- mutate_each(df_class.carr, funs(tolower)) # forçando minúsculas
# tirando acentuação e espaço em branco em excesso
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("á", "a", x))))
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("é", "e", x))))
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("í", "i", x))))
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("ó", "o", x))))
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("ú", "u", x))))
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("ã", "a", x))))
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("õ", "o", x))))
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("ç", "c", x))))
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("â", "a", x))))
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("ê", "e", x))))
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("ô", "o", x))))
df_class.carr <- as.data.frame(sapply(df_class.carr, FUN = function(x) as.character(gsub("  ", " ", x))))
# ATENCAO: tirar brancos no inicio e fim tb!!!!
knitr::kable(head(df_class.carr))
```


----

### Arquivo Processado ###

A arquivo acima foi usado como base para classificar tanto a formação quanto a profissão em um dos 10 campos abaixo:

* CFM - Campo Físico/matemático
* CFQ - campo Físico/Quimico
* CCF - Campo Cálculo/Finanças
* COA - Campo Organizacional/Administrativo
* CJS - Campo Jurídico/Social
* CCP - Campo Comunicação/Persuasão
* CSL - Campo Simbólivo/Linguístico
* CMA - Campo Manual/Artístico
* CCE - Campo Comportamental/Educacional
* CBS - Campo Biológico/Saúde

#### Tabelas de Convesrsão dos Dados ####

Como os campos de profissão e formação têm textos diferentes daqueles encontrados na tabela de Campos Profissionais, foram criadas tabelas de conversão, de forma que os nomes das ocupações/profissões obtidas do respondente possam estar alinhadas com os nomes das carreiras que aparecem na tabela de campos.

#### Critérios usados para as profissões e ocupações que não aparecem na tabela de campos profissionais ####

Sempre que uma profissão/ocupação informada pelo respondente não encontraram correspondentes na tabela de campos profissionais, foram classificadas por similaridade. Adicionalmente, algumas ocupações/formações que não faziam sentido serem usadas para a análise (por exemplo: aposentado, estagiário, etc.).
Estas tabelas de conversão também foram usadas para este fim.

A baixo estão as tabelas usadas para as conversões acima mencionadas:

#### Tabela de Conversão de Profissões ####

```{r,echo=FALSE}
# obtém tabela DE-PARA para profissões, para alinhar com a classificação de Campos Profissionais
# prepara os dados, tirando acentos, brancos em excesso 
f_acentos <- function(df_in) { # funcao que tira os acentos e deixa tudo em minuscula
    df_in <- mutate_each(df_in, funs(tolower)) # forçando minúsculas
    df_in <- as.data.frame(sapply(df_in, FUN = function(x) as.character(gsub("á", "a", x))))
    df_in <- as.data.frame(sapply(df_in, FUN = function(x) as.character(gsub("é", "e", x))))
    df_in <- as.data.frame(sapply(df_in, FUN = function(x) as.character(gsub("í", "i", x))))
    df_in <- as.data.frame(sapply(df_in, FUN = function(x) as.character(gsub("ó", "o", x))))
    df_in <- as.data.frame(sapply(df_in, FUN = function(x) as.character(gsub("ú", "u", x))))
    df_in <- as.data.frame(sapply(df_in, FUN = function(x) as.character(gsub("ã", "a", x))))
    df_in <- as.data.frame(sapply(df_in, FUN = function(x) as.character(gsub("õ", "o", x))))
    df_in <- as.data.frame(sapply(df_in, FUN = function(x) as.character(gsub("ç", "c", x))))
    df_in <- as.data.frame(sapply(df_in, FUN = function(x) as.character(gsub("â", "a", x))))
    df_in <- as.data.frame(sapply(df_in, FUN = function(x) as.character(gsub("ê", "e", x))))
    df_in <- as.data.frame(sapply(df_in, FUN = function(x) as.character(gsub("ô", "o", x))))
    df_in <- as.data.frame(sapply(df_in, FUN = function(x) as.character(gsub("  ", " ", x))))
    return (df_in)
}

df_profs <- read.xlsx2("./data/profs.de.para-V1.xlsx", sheetIndex = 1, header = TRUE)
df_profs <- f_acentos(df_profs)

knitr::kable(df_profs)
```

#### Tabela de Conversão de Formações ####

```{r,echo=FALSE}
# obtém tabela DE-PARA para formações, para alinhar com a classificação de Campos Profissionais
df_forms <- read.xlsx2("./data/forms.de.para-V1.xlsx", sheetIndex = 1, header = TRUE)
df_forms <- f_acentos(df_forms)
knitr::kable(df_forms)
```

### Análise Movimentação entre Campos Profissionais ###

Uma vez classificada cada ocupação e cada formação de acordo com os campos profissionais, foi usado o seguinte critério para considerar que um respondente fez uma movimentação de campo de atuação:

* Se a formação e a profissão do respondente aparecem em ao menos um campo profissional comum, é considerado que ele não realizou movimentação para outro campo profissional
* Os demais respondentes que não se encaixam no critério acima são considerados como tendo realizado movimentação para outro campo profissional

```{r,echo=FALSE}
require("stringr", quietly = TRUE, warn.conflicts = FALSE)
require("reshape2", quietly = TRUE, warn.conflicts = FALSE)

source("./R/f_le_raw_HG.R") # usar esta função para ler os dados novos. 
source("./R/f_tidy_scores_HG.R") # alterada em 07/12/2015 para trazer nome do respondente tb
df_raw_hg <- f_le_raw_HG() # lê toda a amostra de dados HG
df_tidy_hg <- f_tidy_scores_HG(df_raw_hg) # calcula os fatores de acordo com a puntuação

# chama funcao que tira acentos e força minúsculos
df_change <- f_acentos(df_tidy_hg)

# restaura fatores como numericos
df_change <-
    df_change %>%
    mutate(sensibility = as.numeric(as.vector(sensibility)),
           power = as.numeric(as.vector(power)),
           quality = as.numeric(as.vector(quality)),
           exposure = as.numeric(as.vector(exposure)),
           structure = as.numeric(as.vector(structure)),
           imagination = as.numeric(as.vector(imagination)),
           stability = as.numeric(as.vector(stability)),
           contacts = as.numeric(as.vector(contacts)))

# renomeando colunas
df_forms <-
    df_forms %>%
    rename(formacao.em = DE)

# substituindo a coluna de formação antiga para a convertida na tabela principal
df_change <- left_join(df_change, df_forms, by=c("formacao.em")) 
df_change <-
    df_change %>%
    select(-formacao.em) %>%
    rename(formacao.em = PARA)

# renomeando colunas
df_profs <-
    df_profs %>%
    rename(profissao.na.area.de = DE)

# substituindo a coluna de profissão antiga para a convertida na tabela principal
df_change <- left_join(df_change, df_profs, by=c("profissao.na.area.de")) 
df_change <-
    df_change %>%
    select(-profissao.na.area.de) %>%
    rename(profissao.na.area.de = PARA)

# eliminar formação e profissão marcadas como a "eliminar"
df_change <-
    df_change %>%
    filter(formacao.em != "eliminar" & profissao.na.area.de != "eliminar")

# obtendo os scores previstos de acordo com a análise de componentes principais
pca1 = prcomp(df_tidy_hg[,7:14], scale. = TRUE, center = TRUE)
```

```{r,echo=FALSE}
# selecionando apenas amostra para rapidez de processamento, da amostra trabalhada (posteriormente colocar em combobox)
tam.amostra = 1000
my.newdata <- 
    df_change %>%
    sample_n(tam.amostra)
# fazendo para toda a base
#my.newdata.carr <- df_tidy_hg
#tam.amostra = dim(my.newdata)[1]

# calculando os scores
my.prev <- as.data.frame(predict(pca1, newdata=my.newdata))
# criando dataframe por carreira e profissão
my.prev <- cbind(ID = my.newdata$ID, profissao.na.area.de = my.newdata$profissao.na.area.de, 
                 formacao.em = my.newdata$formacao.em,
                 my.prev)
knitr::kable(tam.amostra, caption = "TAMANHO DA AMOSTRA")
```

```{r,echo=FALSE}
# PROFISSAO x CLASSE
# criando novo dataframe para tratar mais de uma profissão por classe de carreira
#----------------------------------------------------------------------------------
df_carr <- data.frame()

for (j in 1:ncol(df_class.carr)) {
    # percorre todas as linhas da coluna corrente de df_class.carr
    for (i in 1:length(my.prev$profissao.na.area.de)) {
        # somente pega o string com match exato (ex. administração)
        i_aux <- sum(!is.na(str_match(df_class.carr[,j],
                                      paste0("^", as.character(my.prev$profissao.na.area.de[i]), "$"))))
        
        # para cada profissão encontrada em uma determinada classe, marca a posição correspondente
        # com 1, na célula do dataframe correspondente. Caso contrario, coloca NA
        if(i_aux) {
            df_carr[i,j] = i_aux
        } else {
            df_carr[i,j] = NA
        }
    }
}
# colocando os nomes das classes no dataframe gerado
names(df_carr) <- colnames(df_class.carr)

# concatenando a coluna de profissoes ao dataframe gerado
my.prev.carr <- cbind(my.prev, df_carr)

# duplicar colunas que aparecem com mais de uma classe

# transformando colunas em valores por linha, eliminando NAs, de forma a poder ter os scores de
# cada profissão duplicado para cada classe onde a profissão se encontra
# Desta forma, a análise não perde a contribuição do score de cada profissão para cada classe
carrMelt <- melt(my.prev.carr,id=c("ID","profissao.na.area.de",
                                   "PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8"),
                 measure.vars=colnames(df_class.carr), na.rm = TRUE)
# mudando o nome da variavel de classe
colnames(carrMelt)[11] <- "class.carr"
# eliminando coluna desnecessária
my.prev.carr <-
    carrMelt %>%
    select (-value)

knitr::kable(head(my.prev.carr[,-1]))
```

```{r,echo=FALSE}
# FORMACAO x CLASSE
# criando novo dataframe para tratar mais de uma formacao por classe de carreira
#----------------------------------------------------------------------------------
df_form <- data.frame()

for (j in 1:ncol(df_class.carr)) {
    # percorre todas as linhas da coluna corrente de df_class.carr
    for (i in 1:length(my.prev$formacao.em)) {
        # somente pega o string com match exato (ex. administração)
        i_aux <- sum(!is.na(str_match(df_class.carr[,j],
                                      paste0("^", as.character(my.prev$formacao.em[i]), "$"))))
        # para cada profissão encontrada em uma determinada classe, marca a posição correspondente
        # com 1, na célula do dataframe correspondente. Caso contrario, coloca NA
        if(i_aux) {
            df_form[i,j] = i_aux
        } else {
            df_form[i,j] = NA
        }
    }
}
# colocando os nomes das classes no dataframe gerado
names(df_form) <- colnames(df_class.carr)

# concatenando a coluna de profissoes ao dataframe gerado
my.prev.form <- cbind(my.prev, df_form)

# duplicar colunas que aparecem com mais de uma classe
# transformando colunas em valores por linha, eliminando NAs, de forma a poder ter os scores de
# cada profissão duplicado para cada classe onde a profissão se encontra
# Desta forma, a análise não perde a contribuição do score de cada profissão para cada classe
formMelt <- melt(my.prev.form,id=c("ID","formacao.em",
                                   "PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8"),
                 measure.vars=colnames(df_class.carr), na.rm = TRUE)
# mudando o nome da variavel de classe
colnames(formMelt)[11] <- "class.carr"
# eliminando coluna desnecessária
my.prev.form <-
    formMelt %>%
    select (-value)

knitr::kable(head(my.prev.form[,-1]))
```

```{r,echo=FALSE}
# Se ID aparece ao menos uma vez no inner_join, significa que a profissão e a carreira
# do respondente ao menos uma vez aparece na mesma catagoria, configurando que não se movimntou
# para outra carreira
df_sem.mov <- inner_join(my.prev.form[,c(1:2,11)], my.prev.carr[,c(1:2,11)],by=c("ID", "class.carr"))
# tirando a duplicidade dos IDs dos respondentes sem movimento, identifico todos os IDs, sem movimentação
# número de IDs da amostra total identificados como não s emovimentando de carreira:
nrow(df_sem.mov)
df_sem.mov <-
    df_sem.mov %>%
    distinct(ID)
# obtendo respondentes com movimento a partir dos dados originais processados, selecionando
# dos dados otais aqueles que não têm o ID encontrado como sem movimento
df_com.mov <-
    my.prev %>%
    filter(!(ID %in% df_sem.mov$ID))
```

### BoxPlots de Scores da Campos de Profissões por Componentes Principais ###

Abaixo seguem os boxplots da distribuição dos scores agrupados por classes de componentes para todos os dados da amostra:

----

#### Respondentes com Movimentação de Carreira por Componente Principal ####


```{r, echo=FALSE, warning=FALSE}
# box plot (colocar no mesmo grip para cada compondente)
# criando tabela com scores e campo que identifica movimento, para plot
# criando coluna que identifica MOVIMENTO (S/N)
# conctenando horizontalmente
my.prev.mov <-
    my.prev %>%
    mutate(MOVIMENTO = ifelse((ID %in% df_sem.mov$ID),"NÃO MUDOU","MUDOU"))

# box plot (colocar no mesmo grid)
require("plotly", quietly = TRUE, warn.conflicts = FALSE)
pc1 <- plot_ly(my.prev.mov, x = PC1, color = MOVIMENTO, type = "box") 
pc1 <- layout(pc1, title = "OPENNESS/EXPLORATION x COMPLIANCE/OBSERVÂNCIA") 
pc1
```



----



```{r, echo=FALSE, warning=FALSE}
# box plot
pc2 <- plot_ly(my.prev.mov, x = PC2, color = MOVIMENTO, type = "box")
pc2 <- layout(pc2, title = "AGREEABLENESS/AMABILIDADE x ANALÍTICO E INDEPENDENTE/FOCO EM RESULTADO")
pc2
```


----



```{r, echo=FALSE, warning=FALSE}
# box plot
pc3 <- plot_ly(my.prev.mov, x = PC3, color = MOVIMENTO, type = "box")
pc3 <- layout(pc3, title = "INVESTIGATIVO/RESEARCH ORIENTED x COMMITMENT/ENGAJAMENTO")
pc3
```


----



```{r, echo=FALSE, warning=FALSE}
# box plot
pc4 <- plot_ly(my.prev.mov, x = PC4, color = MOVIMENTO, type = "box")
pc4 <- layout(pc4, title = "PEOPLE DEVELOPMENT ORIENTED x TASK ORIENTED/ORIENTAÇÃO PARA A TAREFA")
pc4
```


----



```{r, echo=FALSE, warning=FALSE}
# box plot
pc5 <- plot_ly(my.prev.mov, x = PC5, color = MOVIMENTO, type = "box")
pc5 <- layout(pc5, title = "EXTROVERSÃO/AUTENTICIDADE x SOBRIEDADE/COMPOSTURA/COMEDIMENTO")
pc5
```


----



```{r, echo=FALSE, warning=FALSE}
# box plot
pc6 <- plot_ly(my.prev.mov, x = PC6, color = MOVIMENTO, type = "box")
pc6 <- layout(pc6, title = "MANAGEMENT/ASSISTÊNCIA/RECEPTIVIDADE ATIVA")
pc6
```


----



```{r, echo=FALSE, warning=FALSE}
# box plot
pc7 <- plot_ly(my.prev.mov, x = PC7, color = MOVIMENTO, type = "box")
pc7 <- layout(pc7, title = "AUSTERIDADE/PONDERAÇÃO x ADAPTABILIDADE/AJUSTAMENTO)")
pc7
```

